#!/usr/bin/env ruby

require "yaml"
require "net/http"
require "json"
require "erb"

# Merge variables from .env file into environment.
env = YAML.load(File.read(File.join(__dir__, "releasenotes.env"))) rescue {}
env.each { |key, value| ENV[key] ||= value.to_s }

# Base for both Bamboo and JIRA API.
API = Struct.new(:server, :user, :password) do
  def get(query)
    uri = URI.join(server, "/rest/api/latest/", query)
    request = Net::HTTP::Get.new(uri)
    request.basic_auth(user, password)
    request["Accept"] = "application/json"
    http = Net::HTTP.new(uri.hostname, uri.port)
    response = http.request(request)
    JSON.parse(response.body)
  end
end

# Set up Bamboo and JIRA APIs.
bamboo = API.new(ENV["bamboo_Bamboo_Server"], ENV["bamboo_Bamboo_User"], ENV["bamboo_Bamboo_Password"])
jira = API.new(ENV["bamboo_JIRA_Server"], ENV["bamboo_JIRA_User"], ENV["bamboo_JIRA_Password"])

# Fetch data of both current build and build plan from Bamboo.
build_data = bamboo.get("result/#{ENV["bamboo_Plan_Key"]}-#{ENV["bamboo_Build_Number"]}?expand=jiraIssues")
build_plan_data = bamboo.get("result/#{ENV["bamboo_Plan_Key"]}?expand=results.result.jiraIssues")

# Extract project name and issue keys.
project_name = build_data["projectName"]
all_build_results = [build_data] + build_plan_data["results"]["result"]
issue_keys = all_build_results.collect do |result|
  result["jiraIssues"]["issue"].collect { |issue| issue["key"] }
end.flatten.uniq

# A JIRA issue.
class Issue

  attr_accessor :key, :url, :type, :summary, :description, :status, :children, :is_child, :parent, :sprint, :blocker_keys

  def initialize(data)
    @key = data["key"]
    @url = URI.join(ENV["bamboo_JIRA_Server"], "browse/", @key)
    @type = data["fields"]["issuetype"]["name"]
    @summary = data["fields"]["summary"]
    @description = data["fields"]["description"]
    @status = data["fields"]["status"]["name"].downcase
    @children = []
    @is_child = false
    @parent = data["fields"]["parent"]["key"] if data["fields"]["parent"]
    # Extract sprint name from custom field.
    @sprint = begin
      sprint = data["fields"][ENV["bamboo_Sprint_Field"]]
      sprint_data = sprint.first.match(/^.+\[(.+)\]$/)[1]
      parsed_sprint_data = Hash[sprint_data.split(",").collect { |s| s.split("=") }]
      parsed_sprint_data["name"]
    rescue
      "Backlog"
    end
    # Select keys of issues with an inward blocking relationship to this one.
    @blocker_keys = data["fields"]["issuelinks"].select do |link|
      link["type"]["name"] == "Blocks" && link["inwardIssue"]
    end.collect do |link|
      link["inwardIssue"]["key"]
    end
  end

  # Recursively generates markdown for this issue and its child issues.
  def to_md(level=0)
    issue_md = ("\t" * level) + "* [#{@type}: #{@summary}](#{@url}) (#{@status})"
    children_md = @children.collect { |child| child.to_md(level+1) }
    ([issue_md] + children_md) * "\n"
  end

end

# Fetch JIRA issues based on issue keys from Bamboo and, if given, selected issue types.
jql_query = "key in (#{issue_keys.join(",")})"
if ENV["bamboo_Issue_Types"]
  issue_types = ENV["bamboo_Issue_Types"].split(/,\s?/).map { |type| %Q("#{type}") }
  jql_query << " AND type in (#{issue_types.join(",")})"
end
search_result = jira.get("search?jql=#{URI.encode(jql_query)}" +
  "&fields=summary,issuetype,status,parent,issuelinks,#{ENV["bamboo_Sprint_Field"]}" +
  "&maxResults=100&validateQuery=false")

# Store issues in a hash according to their key.
jira_issues = {}
search_result["issues"].each do |issue_data|
  issue = Issue.new(issue_data)
  jira_issues[issue.key] = issue
end

# Create relationships according to parent field and blocker keys.
# Only create relationships with issues that exist here and only within the same sprint.
jira_issues.each do |key, issue|
  # If issue has a parent issue, add this issue to its parent's children.
  if issue.parent && (parent = jira_issues[issue.parent]) && (parent.sprint == issue.sprint)
    parent.children << issue
    issue.is_child = true
  end
  # If issue has blockers, add blockers to this issues children.
  issue.blocker_keys.each do |blocker_key|
    if (blocker = jira_issues[blocker_key]) && (blocker.sprint == issue.sprint)
      issue.children << blocker
      blocker.is_child = true
    end
  end
end

# Remove child issues from top-level, then group top-level issues by sprint.
sprints = jira_issues.values.reject(&:is_child).group_by(&:sprint)

# Get custom release notes.
release_notes = ENV["bamboo_Release_Notes"]

# ERB template for release notes.
template = <<ERB
# <%= project_name %>

<%= release_notes %>

<% sprints.each_pair do |sprint, issues| %>

## <%= sprint %>

<% issues.each do |issue| %>
<%= issue.to_md %>

<% end %>
<% end %>
ERB

# Render release notes to file.
output = ERB.new(template, nil, "<>").result(binding)
File.write(ENV["bamboo_Release_Notes_File"] || "releasenotes.md", output)
